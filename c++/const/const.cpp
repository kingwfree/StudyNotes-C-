#include <iostream>
/*
C++中的const常量与宏定义不同
const常量是由编译器处理的，提供类型检查和作用域检查
宏定义由预处理器处理，单纯的文本替换


C++中的const常量可能分配存储空间,也可能不分配存储空间
当const常量为全局，并且需要在其它文件中使用，会分配存储空间
当使用&操作符，取const常量的地址时，会分配存储空间
当const int &a = 10; const修饰引用时，也会分配存储空间
*/
int main() {
	int tmp = 0;
	

	//定义a,b为常量，即只读
	const int a=1;
	int const b=1;

	/*
	根据C的标准。
	C99支持数组使用 变量的值 作为 长度，而C90 不支持，数组长度必须是 常量值。
	int n = 10;
	int arr[n] = { 0,1 };//会报错

	*/
	int arr[a] = { 0};
	
	//const int * 类型的值不能用于初始化 int * 类型的实体
	//int* p = &a;

	//c里a是可以被改变的,通过 int* p = &a; a =10;
	//c++里虽然*p是可修改的，但是a的内容还是无法被修改，原因是：
	//当我们声明const类型时，不会开辟空间给它即这个const类型的变量不会有地址，而是会在常量区域创建一个符号表（即key和value如：a 1)。
	//当我们使用const类型的变量时，会直接取它的值。
	/*
		数组的数组名也是一个常量，存放地址
	*/
	//如果对一个常量取地址，编译器会临时开辟一个空间temp.让这个指针存放这个临时空间的地址
	int* p = (int*)&a;
	*p = 2;
	bool f = (p == &a);
	printf("a=%d *p=%d f=%d ", a,*p,f);//1 2 1

	//定义内存数据为只读
	const int* c=&tmp;
	
	//定义指针为只读
	//int* const s = &a; (c++中只读类型变量（const int）不能用于初始化只读指针(int* const))；
	//接收可修改变量的地址
	int* const d=&tmp;
	
	//定义内存数据和指针为只读
	const int* const e=d;

	//tmp可以正常赋值，但是*c和d不能被重新赋值
	tmp = 3;
	printf("tmp=%d\n",tmp);


	//引用
	/*
	引用：简单的讲就是某个变量的别名。
	对一个变量的“引用”的所有操作，实际上都是对其所代表的（原来的）变量的操作。

	对引用而言，新定义的引用变量是不申请内存单元的，与它引用的对象共用同一块变量存储单元，
	正是因为这一特性，在声明一个引用的同时必须将其初始化
	
	*/

	int q,r=2;
	int &w = q;
	w = 4;
	printf("q=%d,w=%d\n", q, w);

	//声明常引用，不允许改变b的值
	const int &t = r;
	//t = 5; //错误，t不能被赋值

	/*
	在以表达式的形式对常引用进行声明时，
	系统将自动生成一个临时变量，用这个临时变量存表达的值，
	之后常引用实是这个临时变量的引用。 
	*/
	int temp = q + 7;
	const int& u = temp;
	printf("u=%d\n", temp);


	return 0;
}